  <?xml version="1.0" encoding="utf-8"?>
 <topic id="8e1a441f-69ae-49fe-bf11-cf9ec7a9a601" revisionNumber="1">
  <developerConceptualDocument
  xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5"
  xmlns:xlink="http://www.w3.org/1999/xlink">

  
  
  

      <!--
      <summary>
        <para>Optional summary abstract</para>
      </summary>
      -->

      <introduction>
        <!-- Uncomment this to generate an outline of the section and sub-section
             titles.  Specify a numeric value as the inner text to limit it to
             a specific number of sub-topics when creating the outline.  Specify
             zero (0) to limit it to top-level sections only.  -->
        <!-- <autoOutline /> -->

    
      </introduction>

      <!-- Add one or more top-level section elements.  These are collapsible.
           If using <autoOutline />, add an address attribute to identify it
           and specify a title so that it can be jumped to with a hyperlink. -->
      <section address="ox4">
      
        <content>


          <para>
            This is the class which captures all the information for execution of the application very similar to the command used to execute the application on the desktop (<legacyBold>SimpleApplication -input input.txt -outputfiles 3</legacyBold>) as depicted in the figure below.
          </para>
          <mediaLink>
            <image xlink:href="tutorial5"/>
          </mediaLink>


          <para>
            The above figure depicts the mapping understanding required to be able to translate the desktop commandline to a compatible Application Description.

          </para>
          <para>
            <legacyBold>SimpleApplication -input input.txt -outputfiles 3</legacyBold>

          </para>
          <para>
            Here the "SimpleApplication" is the name of the executable to be invoked to start the application and thus it is associated to the "Executable" field of the CommandLineArgument class.
          </para>

          <para>
            The "-input" and "-outfiles" fields are associated to the "FormatString" field of the CommandLineArgument class.
          </para>
          <code title="FormatString field association with its commandline counterpart">
            new CommandLineArgument()
            {
            Name = "InputFile",
            FormatString = "-input {0}",
            Required = Required.Mandatory,
            CommandLineArgType = CommandLineArgType.SingleReferenceInputArgument
            },
            // The second parameter is to specify the number of output files
            new CommandLineArgument()
            {
            Name = "NumberOutFiles",
            FormatString = "-outfiles {0}",
            Required = Required.Mandatory,
            CommandLineArgType = CommandLineArgType.SingleLiteralArgument
            },

          </code>

          <list class="bullet">
            <listItem>
              <para>
                The values input next to "-input" is associated to SingleReferenceInputArgument because we have a single valued input file which is to be referenced from the local machine which can have any name.
              </para>
            </listItem>

            <listItem>
              <para>
                Now in this example if the Desktop application command were to take different no of input files in different instances, then in that case instead of "SingleReferenceInputArgument" we should use "MultiReferenceOutputArgument". But if the application were to take a constant no of files (more than 1 file as input) but not a variable number of input files then we would still use "SingleReferenceInputArgument".
              </para>
            </listItem>


            <listItem>
              <para>
                Now coming to the value input next to "-outfiles" field in the desktop commandline, this is associated to "SingleLiteralArgument" for the reason that, the value input into this field is required to be a number and not a file or reference to a file. This value states the number of output files to be generated by the application being executed after successful execution.
              </para>
            </listItem>

            <listItem>
              <para>
                To accomodate the Output files another CommandLineArgument object is created with the type "MultipleReferenceOutputArgument", this type of an argument type is used when we dont know the required number files to be generated after execution.
              </para>
            </listItem>

            <listItem>
              <para>
                Now if this example if the Desktop application command were to look like this <legacyBold>SimpleApplication -input input.txt -outputfiles output.txt</legacyBold> : here we would have considered using the value "output.txt" as an "SingleReferenceOutputArgument" and not as an "SingleLiteralArgument".
              </para>
            </listItem>

          </list>











          <para>
            <legacyBold>Corresponding Code would look like this after the mapping is done</legacyBold>
          </para>
          <code title="Example Mapping from CommandLine to GenericWorker understandable format">
            Console.Write("Create application description.. ");

            // The description is needed to define, which input / outputfiles and arguments are required to run the application
            VENUSApplicationDescription applicationDescription = new VENUSApplicationDescription();

            // The application needs a unique name so that the GenericWorker can identify the application.
            var myApplicationName = "http://MySimpleApplication";
            applicationDescription.ApplicationIdentificationURI = myApplicationName;

            // Now we need to define arguments for the commandline
            VENUSCommandTemplate myTemplate = new VENUSCommandTemplate();
            myTemplate.Path = string.Empty;                     // You could a path here, which is added to the environment PATH variable
            myTemplate.Executable = "SimpleApplication.bat";    // This is the executable which will be lunched by the GenericWorker
            myTemplate.Args = new List of CommandLineArgument ()
            {
            // For our application a single input file is needed, so we create a SingleReferenceInputArgument
            new CommandLineArgument()
            {
            Name = "InputFile",
            FormatString = "-input {0}",
            Required = Required.Mandatory,
            CommandLineArgType = CommandLineArgType.SingleReferenceInputArgument
            },
            // The second parameter is to specify the number of output files
            new CommandLineArgument()
            {
            Name = "NumberOutFiles",
            FormatString = "-outfiles {0}",
            Required = Required.Mandatory,
            CommandLineArgType = CommandLineArgType.SingleLiteralArgument
            },

            // The application creates a yet not known number of output files.
            // So we create a mandatory MultipleReferenceOutputArgument to be able to set the number of
            // inputfiles when submitting the job.
            new CommandLineArgument()
            {
            Name = "OutputFiles",
            FormatString = "",
            Required = Required.Mandatory,
            CommandLineArgType = CommandLineArgType.MultipleReferenceOutputArgument
            }
            };

            applicationDescription.CommandTemplate = myTemplate;

            Console.WriteLine("Done");
          </code>


          <alert class="note">

            <para>
              More on CommandLineArgType ENUM values can be found in the following <link xlink:href="6dd926cc-56b3-4789-8b40-67d6fc566bb6">link</link>.
            </para>
          </alert>
          <para>
          <legacyBold>
            Next Topic:
          </legacyBold>
          <link xlink:href="aff93c1d-2909-41c4-a66b-e24be9f1aaa8">
            Zipping and Uploading ApplicationDescription and Application executable files to the Cloud 
          </link>
          </para>
        </content>
      </section>

      <relatedTopics>
        <!-- One or more of the following:
             - A local link
             - An external link
             - A code entity reference

        <link xlink:href="Other Topic's ID"/>
        <link xlink:href="Other Topic's ID">Link inner text</link>

        <externalLink>
            <linkText>Link text</linkText>
            <linkAlternateText>Optional alternate link text</linkAlternateText>
            <linkUri>URI</linkUri>
        </externalLink>

        <codeEntityReference>API member ID</codeEntityReference>

        Examples:

        <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8270" />
        <link xlink:href="00e97994-e9e6-46e0-b420-5be86b2f8278">Some other topic</link>

        <externalLink>
            <linkText>SHFB on CodePlex</linkText>
            <linkAlternateText>Go to CodePlex</linkAlternateText>
            <linkUri>http://shfb.codeplex.com</linkUri>
        </externalLink>

        <codeEntityReference>T:TestDoc.TestClass</codeEntityReference>
        <codeEntityReference>P:TestDoc.TestClass.SomeProperty</codeEntityReference>
        <codeEntityReference>M:TestDoc.TestClass.#ctor</codeEntityReference>
        <codeEntityReference>M:TestDoc.TestClass.#ctor(System.String,System.Int32)</codeEntityReference>
        <codeEntityReference>M:TestDoc.TestClass.ToString</codeEntityReference>
        <codeEntityReference>M:TestDoc.TestClass.FirstMethod</codeEntityReference>
        <codeEntityReference>M:TestDoc.TestClass.SecondMethod(System.Int32,System.String)</codeEntityReference>
        -->
      </relatedTopics>
    </developerConceptualDocument>
  </topic>
